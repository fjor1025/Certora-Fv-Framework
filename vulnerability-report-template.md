# [Vulnerability Class] in [Contract::function] Allows [Impact]

## Summary

[Use the Kill-Shot Pattern: `{root cause} will cause {impact} for {affected party} because {actor} can {attack path}.` Write 2-3 sentences. Include the constraint envelope: state when the attack works AND when it doesn't.]

**Quick facts:**
- **Severity:** [Critical/High/Medium/Low]
- **Location:** `contracts/[path]/Contract.sol` (line [X])
- **Commit:** [git commit hash or tag]  
- **Chain/Network:** [Mainnet / Testnet / L2 name] 
- **Deployed address:** [0x... if live bounty, N/A if contest]  
- **Attack cost:** [X ETH/tokens] | **Profit:** [Y ETH/tokens]
- **Privileges required:** [None/User/Admin]
- **Semantic phase:** [VALIDATION / SNAPSHOT / ACCOUNTING / MUTATION / COMMIT]  

---

## Vulnerability Details

### The Problem

[Explain the root cause in technical but natural language. Start with "The vulnerability exists because..." or "I found that..." Use paragraphs, not bullet points.]

The vulnerable code is in `[Contract.sol::function()]` at lines [X-Y]:

```solidity
function vulnerableFunction([params]) external {
    // [!] ISSUE: [One line explaining what's wrong]
    [vulnerable code snippet - 5-10 lines max]
    // Missing: [what validation/check is absent]
}
```

[Explain WHY this is vulnerable. What assumption does the code make? What does it fail to check?]

### Attack Scenario

[Write a natural narrative of how the attack works. Use "First... Then... Finally..." structure]

1. **Initial state:** [Describe preconditions naturally]
2. **Attacker action:** [What the attacker does - be specific]
3. **Vulnerable execution:** [What happens inside the contract]
4. **Result:** [What state changes occur]

**Attack timing:**  
- **Transactions required:** [1 (atomic) / N (multi-step) / N across M blocks]
- **MEV dependency:** [None / Requires frontrunning / Sandwichable / Backrunnable]
- **Time window:** [Unlimited / During oracle lag / During governance delay / Within N blocks]
- **Repeatability:** [One-shot / Repeatable at cost X / Unlimited]

The key issue is that [explain the core failure - missing check, wrong assumption, logic error].

### Why This Matters

[Explain the impact in natural language. Start broad, then get specific with numbers.]

**Direct impact:**
- [Primary consequence - e.g., "Attacker can drain X ETH from the protocol"]
- [Secondary consequence - e.g., "All users with pending withdrawals lose access"]

**Economic analysis:**
- Attacker spends: ~[X] ETH (gas + initial capital)
- Attacker gains: [Y] ETH minimum ([Z]% ROI)
- Protocol loses: [W] ETH (current TVL: [T] ETH)
- Repeatability: [Yes/No/Limited by X]

[If relevant, explain why this isn't just a "design choice" or "known limitation"]

### Limitations & Constraints  ← NEW v2.1

[State explicitly when the attack does NOT work. Judges discover omitted constraints and treat them as dishonesty.]

**The attack works when:**
- [Condition 1 - e.g., "TVL > 0 (default state since deployment)"]
- [Condition 2 - e.g., "Contract is not paused"]

**The attack does NOT work when:**
- [Condition 1 - e.g., "Contract is paused (but pause requires 3/5 multisig + 48h timelock)"]
- [Condition 2 - e.g., "Vault has zero deposits (unrealistic after launch)"]

**Detection & Response:**  ← NEW v2.1
- **Observable on-chain?** [Yes — emits [Event] / No — indistinguishable from normal usage]
- **Protocol can respond?** [Yes but too slow (timelock) / No pause mechanism / Yes — but attack is atomic]
- **MEV protection relevant?** [Not applicable / Attacker must frontrun / Attack is backrunnable]

---

## Proof of Concept

I've created a PoC that demonstrates this vulnerability on a mainnet fork. The test shows:
- Attacker starts with [X] ETH (just gas money)
- Protocol holds [Y] ETH in vulnerable contract
- After exploit: Attacker has [Z] ETH profit, protocol loses [W] ETH

### Test Code

[Choose the PoC scaffold matching your target ecosystem:]  

**Solidity / Foundry:**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import {[Contract]} from "[path]";

contract ExploitTest is Test {
    [Contract] target;
    address attacker = address(0x1337);
    
    function setUp() public {
        // Fork mainnet at recent block
        vm.createSelectFork(vm.envString("MAINNET_RPC"), [BLOCK_NUMBER]);
        
        // [Setup protocol state]
        target = [Contract]([ADDRESS]);
        
        // [Setup attacker with minimal funds]
        vm.deal(attacker, 1 ether); // Just gas money
    }
    
    function testExploit() public {
        // Record balances before
        uint256 protocolBefore = [relevant balance];
        uint256 attackerBefore = [attacker balance];
        
        // Execute attack
        vm.startPrank(attacker);
        [
            // Step-by-step exploit
            // Keep it minimal - just the key calls
        ]
        vm.stopPrank();
        
        // Verify impact
        uint256 protocolAfter = [relevant balance];
        uint256 attackerAfter = [attacker balance];
        
        uint256 protocolLoss = protocolBefore - protocolAfter;
        uint256 attackerProfit = attackerAfter - attackerBefore;
        
        console.log("Protocol lost:", protocolLoss);
        console.log("Attacker gained:", attackerProfit);
        
        // Assertions
        assertGt(protocolLoss, 0, "Protocol should lose funds");
        assertGt(attackerProfit, 0, "Attacker should profit");
    }
}
```

**Go / Cosmos SDK:** 
```go
func TestExploit_DrainModule(t *testing.T) {
    // Setup: module holds funds
    app := simapp.Setup(false)
    ctx := app.BaseContext()
    
    // Attack: unprivileged user triggers vulnerable handler
    attacker := sdk.AccAddress([]byte("attacker"))
    msg := types.NewMsgExploit(attacker, sdk.NewInt(1000))
    _, err := app.MsgServiceRouter().Handler(msg)(ctx, msg)
    require.NoError(t, err)
    
    // Result: attacker has module funds
    attackerBal := app.BankKeeper.GetBalance(ctx, attacker, "stake")
    require.Equal(t, sdk.NewInt(1000), attackerBal.Amount)
}
```

**Rust / CosmWasm:**  
```rust
#[test]
fn test_exploit_drain_contract() {
    let mut deps = mock_dependencies();
    setup_contract(deps.as_mut(), 1000u128);
    
    let attacker = Addr::unchecked("attacker");
    let msg = ExecuteMsg::Withdraw { amount: Uint128::new(1000) };
    let res = execute(deps.as_mut(), mock_env(), mock_info(attacker.as_str(), &[]), msg);
    
    assert!(res.is_ok());
    // Verify BankMsg::Send with full contract balance
}
```

**Cairo / StarkNet:**  
```cairo
#[test]
fn test_exploit() {
    let contract = deploy_contract();
    // Setup state, execute attack, verify drain
    // Show felt252 arithmetic with actual prime field values
}
```

[For Solana/Anchor, Substrate, Algorand/PyTeal: see report-writing.md Cross-Chain section for PoC patterns.]

### Running the PoC

```bash
# Set your RPC URL
export MAINNET_RPC="[your_rpc_url]"

# Run the test
forge test --match-test testExploit -vvv

# For detailed traces
forge test --match-test testExploit -vvvv
```

**Expected output:**
```
[PASS] testExploit (gas: [X])
Logs:
  Protocol lost: [Y] ETH
  Attacker gained: [Z] ETH
```

### Key Observations

[Explain what the PoC proves - reference specific console.log outputs or assertions. Write naturally.]

The test demonstrates that [key point from PoC]. Note that [important detail that proves it's not a theoretical issue].

---

## Impact Assessment

This vulnerability allows [who] to [do what], resulting in [consequence].

**Severity justification for [Critical/High/Medium/Low]:**

[Explain in a paragraph why this deserves the severity rating. Reference specific criteria from the contest/platform if relevant. Be honest - if there are limitations or conditions, mention them.]

Key factors:
- **Fund loss:** [Yes/No] - [Direct/Indirect path to value extraction]
- **Privilege required:** [None/User/Admin] - [Explanation]
- **Attack complexity:** [Low/Medium/High] - [Why]
- **Likelihood:** [High/Medium/Low] - [Current state makes this X likely]
- **Detection difficulty:** [Easy/Hard/Silent] - [Events emitted? Distinguishable from normal use?]  

### Preemptive Objection Defense

[Address each applicable judge objection pattern before the judge raises it. Delete rows that don't apply.]

| Potential Objection | My Response |
|-------------------|-------------|
| "Requires admin/trusted role" | [Explain why no privileges needed, or why admin compromise is in-scope per platform rules] |
| "This is by design" | [Quote NatSpec, README, or tests that show developer intended different behavior] |
| "Duplicate of #X" | [Explain different root cause, different semantic phase, different fix] |
| "Low likelihood / needs specific conditions" | [Argue conditions are default/common state] |
| "Known issue / previous audit" | [Cite specific previous audit finding and explain why yours is different] |
| "Out of scope" | [Explain why root cause is in the in-scope contract] |

---

## Recommended Mitigation

[Explain the fix in natural language first, then show code]

The vulnerability can be fixed by [explanation of approach]. This prevents the exploit because [reasoning].

### Code Changes

```diff
function vulnerableFunction([params]) external {
+    // Add validation for [what]
+    require([condition], "[error message]");
+    
     // Existing code
     [...]
     
-    // Remove problematic pattern
-    [old code]
+    // Replace with secure alternative
+    [new code]
}
```

### Additional Recommendations

[If there are architectural changes or broader improvements, mention them here. Keep it practical.]

1. [Recommendation 1]
2. [Recommendation 2]
3. [Optional: Consider adding [feature] to prevent similar issues]

---

## References

[If applicable, link to:]
- Similar vulnerabilities in other protocols
- Relevant security best practices
- Documentation that contradicts the implementation

---

**Notes for reviewers:**
[Any context that helps reviewers understand edge cases, why you tested certain scenarios, or clarifications about scope. Keep this brief - 2-3 sentences max.]

---

## Pre-Submission Checklist

*Run through this before hitting Submit. Every unchecked box is a rejection vector.*

**Defense Gate (from report-writing.md):**
- [ ] Known issues list / README checked — this finding is NOT listed
- [ ] Previous audit reports checked — this finding was NOT previously reported
- [ ] Contract/function is confirmed in-scope
- [ ] If similar pattern exists, duplicate differentiation is stated in report

**60-Second Test:**
- [ ] A reader can answer "What breaks?" from the first paragraph alone
- [ ] A reader can answer "Who loses what?" without reading the PoC
- [ ] A reader can answer "How hard is it to exploit?" from the report text

**Quality Checks:**
- [ ] Title = `[Severity]: [Root cause] in [Location] [allows] [consequence]`
- [ ] First paragraph follows Kill-Shot pattern with constraint envelope
- [ ] Zero weasel words (`could`, `might`, `potentially`)
- [ ] Exact location: file, function, line number
- [ ] Concrete impact: dollars, users, duration — not "funds at risk"
- [ ] Working PoC: compiles, runs, has assertions, has comments
- [ ] Root cause: single sentence, not a code walkthrough
- [ ] Not a design choice: evidence developer intended different behavior
- [ ] Recommendation: diff-style fix at exact location
- [ ] Constraint envelope: attack conditions AND failure conditions both stated
- [ ] Objection defense: applicable judge objections addressed

**Methodology Validation:**
- [ ] Reachability — code path executes on live chain
- [ ] State Freshness — exploit works with realistic current state
- [ ] Execution Closure — all external interactions modeled
- [ ] Economic Realism — attack is profitable or meaningful
- [ ] Detection & Response — protocol's ability to observe and halt assessed
